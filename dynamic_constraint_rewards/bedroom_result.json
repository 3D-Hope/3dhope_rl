{
  "success": true,
  "raw_response": "import torch\nimport torch.nn.functional as F\nimport math\n\n# Assume a default idx_to_labels for a bedroom if not provided for robust testing\nDEFAULT_BEDROOM_IDX_TO_LABELS = {\n    '0': 'armchair', '1': 'bookshelf', '2': 'cabinet', '3': 'ceiling_lamp', '4': 'chair',\n    '5': 'children_cabinet', '6': 'coffee_table', '7': 'desk', '8': 'double_bed',\n    '9': 'dressing_chair', '10': 'dressing_table', '11': 'kids_bed', '12': 'nightstand',\n    '13': 'pendant_lamp', '14': 'shelf', '15': 'single_bed', '16': 'sofa', '17': 'stool',\n    '18': 'table', '19': 'tv_stand', '20': 'wardrobe', '21': 'empty' # Placeholder for empty slot\n}\n\ndef _get_object_indices_from_labels(labels_to_idx, target_labels):\n    \"\"\"\n    Helper to get a list of integer indices for given string labels, handling missing labels.\n    Returns a list of valid indices, or [-1] if no target labels are found in the mapping.\n    \"\"\"\n    indices = []\n    if isinstance(target_labels, str):\n        target_labels = [target_labels]\n    for label in target_labels:\n        idx = labels_to_idx.get(label, -1)\n        if idx != -1:\n            indices.append(idx)\n    return indices if indices else [-1]\n\n\ndef compute_bedroom_setup_reward(parsed_scene, **kwargs):\n    \"\"\"\n    Reward function for: \"Make a bedroom with a bed facing a tv stand and there should be 2 nightstands around the bed\"\n    \n    Requirements:\n    1. Scene must have a bed (any type: double_bed, single_bed, or kids_bed).\n    2. Scene must have a tv stand.\n    3. Scene must have at least two nightstands.\n    4. The primary bed should face the primary tv stand (orientation alignment).\n    5. Two nightstands should be positioned \"around\" the bed (close to the bed and ideally on different sides).\n    \n    Args:\n        parsed_scene: Dict with scene data including positions, object_indices, is_empty, orientations, device.\n        **kwargs: Optional, can include 'idx_to_labels' for object mapping.\n    \n    Returns:\n        rewards: Tensor of shape (B,) with constraint satisfaction rewards for each scene in the batch.\n    \"\"\"\n    device = parsed_scene[\"device\"]\n    B = parsed_scene[\"positions\"].shape[0]\n    \n    is_empty = parsed_scene[\"is_empty\"]\n    object_indices = parsed_scene[\"object_indices\"]\n    positions = parsed_scene[\"positions\"]\n    orientations = parsed_scene[\"orientations\"] # [cos_theta, sin_theta] for Z-axis rotation\n    \n    # Get object label mapping, use default if not provided for robustness\n    idx_to_labels = kwargs.get(\"idx_to_labels\", DEFAULT_BEDROOM_IDX_TO_LABELS)\n    # Ensure keys are integers for comparison with object_indices\n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    \n    # Find required object indices using the helper\n    bed_indices_candidates = _get_object_indices_from_labels(labels_to_idx, [\"double_bed\", \"single_bed\", \"kids_bed\"])\n    tv_stand_idx = labels_to_idx.get(\"tv_stand\", -1)\n    nightstand_idx = labels_to_idx.get(\"nightstand\", -1)\n    \n    rewards = torch.zeros(B, device=device)\n    \n    # --- Reward Component Hyperparameters ---\n    EXISTENCE_REWARD_BED = 1.0\n    EXISTENCE_REWARD_TV_STAND = 1.0\n    EXISTENCE_REWARD_NIGHTSTAND_PER = 0.5 # Awarded for each nightstand, up to 2\n    \n    FACING_REWARD_SCALE = 2.0 # Max 2 points for facing\n    \n    NIGHTSTAND_PROXIMITY_MAX_DIST = 1.5 # meters, max distance for a nightstand to be \"around\" the bed\n    NIGHTSTAND_PROXIMITY_REWARD_FACTOR = 1.0 # Max reward for proximity per nightstand\n    NIGHTSTAND_SIDE_BONUS_REWARD = 1.0 # Bonus for having nightstands on different sides\n    NIGHTSTAND_MIN_SIDE_PROJECTION_ABS = 0.3 # Minimum absolute projection on bed's side axis to count as 'on the side'\n    \n    for b in range(B):\n        batch_reward = 0.0\n        \n        # Filter for valid (non-empty) objects in the current scene batch\n        valid_mask = ~is_empty[b]\n        valid_indices = object_indices[b][valid_mask]\n        valid_positions = positions[b][valid_mask]\n        valid_orientations = orientations[b][valid_mask]\n        \n        if valid_indices.numel() == 0: # Handle empty scenes\n            rewards[b] = 0.0\n            continue\n        \n        # --- Component 1: Existence of required objects ---\n        \n        # Check for bed\n        has_bed = False\n        bed_mask = torch.zeros_like(valid_indices, dtype=torch.bool, device=device)\n        for idx in bed_indices_candidates:\n            if idx != -1:\n                current_bed_mask = (valid_indices == idx)\n                if current_bed_mask.any():\n                    has_bed = True\n                    # Combine masks for all bed types, but we will pick the first one for spatial calcs\n                    bed_mask = bed_mask | current_bed_mask\n        \n        if has_bed:\n            batch_reward += EXISTENCE_REWARD_BED\n        \n        # Check for TV stand\n        tv_stand_mask = (valid_indices == tv_stand_idx) if tv_stand_idx != -1 else torch.zeros_like(valid_indices, dtype=torch.bool, device=device)\n        has_tv_stand = tv_stand_mask.any().item()\n        if has_tv_stand:\n            batch_reward += EXISTENCE_REWARD_TV_STAND\n        \n        # Check for nightstands (at least two)\n        nightstand_mask = (valid_indices == nightstand_idx) if nightstand_idx != -1 else torch.zeros_like(valid_indices, dtype=torch.bool, device=device)\n        num_nightstands_found = nightstand_mask.sum().item()\n        \n        batch_reward += min(num_nightstands_found, 2) * EXISTENCE_REWARD_NIGHTSTAND_PER\n        \n        # --- Component 2: Bed facing TV stand ---\n        if has_bed and has_tv_stand:\n            # Pick the first bed and first TV stand found\n            bed_pos = valid_positions[bed_mask][0]\n            tv_pos = valid_positions[tv_stand_mask][0]\n            bed_orient = valid_orientations[bed_mask][0] # [cos_theta, sin_theta]\n            \n            # Calculate direction from bed to TV in XZ plane\n            direction_vec_xz = tv_pos[[0, 2]] - bed_pos[[0, 2]]\n            direction_vec_xz_norm = torch.norm(direction_vec_xz)\n            \n            if direction_vec_xz_norm > 1e-6: # Avoid division by zero\n                direction_vec_xz = direction_vec_xz / direction_vec_xz_norm\n                \n                # Bed's forward orientation vector in XZ plane is directly given by bed_orient\n                bed_forward_xz = bed_orient \n                \n                # Calculate alignment (dot product). 1 for perfect, -1 for opposite.\n                alignment = torch.dot(bed_forward_xz, direction_vec_xz)\n                \n                # Scale alignment from [-1, 1] to [0, 1] then apply reward scale [0, FACING_REWARD_SCALE]\n                facing_reward = (alignment + 1.0) / 2.0 * FACING_REWARD_SCALE\n                batch_reward += facing_reward.item()\n        \n        # --- Component 3: Two nightstands around the bed ---\n        if has_bed and num_nightstands_found >= 2:\n            bed_pos = valid_positions[bed_mask][0]\n            bed_orient = valid_orientations[bed_mask][0] # [cos_theta, sin_theta]\n            \n            nightstand_positions = valid_positions[nightstand_mask]\n            \n            # Identify bed's side vector (rotated 90 degrees counter-clockwise from forward in XZ)\n            # If forward is (cos, sin), side is (-sin, cos) in XZ\n            bed_side_xz = torch.tensor([-bed_orient[1], bed_orient[0]], device=device)\n            \n            # Calculate XZ distances from bed to all nightstands\n            distances_xz = torch.norm(nightstand_positions[:, [0, 2]] - bed_pos[[0, 2]], dim=1)\n            \n            # Filter nightstands by proximity to the bed\n            proximal_nightstand_mask = distances_xz < NIGHTSTAND_PROXIMITY_MAX_DIST\n            proximal_nightstand_positions = nightstand_positions[proximal_nightstand_mask]\n            proximal_distances_xz = distances_xz[proximal_nightstand_mask]\n            \n            if proximal_nightstand_positions.shape[0] >= 2:\n                # Calculate relative XZ positions to the bed for proximal nightstands\n                relative_positions_xz = proximal_nightstand_positions[:, [0, 2]] - bed_pos[[0, 2]]\n                \n                # Project relative positions onto the bed's side vector to determine left/right placement\n                side_projections = torch.sum(relative_positions_xz * bed_side_xz, dim=1)\n                \n                # Find candidates for nightstands on \"left\" (negative projection) and \"right\" (positive projection)\n                # Requires a minimum projection magnitude to avoid counting objects directly in front/behind\n                left_candidates_mask = side_projections < -NIGHTSTAND_MIN_SIDE_PROJECTION_ABS\n                right_candidates_mask = side_projections > NIGHTSTAND_MIN_SIDE_PROJECTION_ABS\n                \n                found_left_nightstand = left_candidates_mask.any()\n                found_right_nightstand = right_candidates_mask.any()\n                \n                if found_left_nightstand and found_right_nightstand:\n                    # Select the closest nightstand from each side\n                    closest_left_dist = torch.min(proximal_distances_xz[left_candidates_mask])\n                    closest_right_dist = torch.min(proximal_distances_xz[right_candidates_mask])\n                    \n                    # Proximity reward for these two nightstands\n                    batch_reward += NIGHTSTAND_PROXIMITY_REWARD_FACTOR * (1.0 - closest_left_dist / NIGHTSTAND_PROXIMITY_MAX_DIST)\n                    batch_reward += NIGHTSTAND_PROXIMITY_REWARD_FACTOR * (1.0 - closest_right_dist / NIGHTSTAND_PROXIMITY_MAX_DIST)\n                    \n                    # Bonus for having nightstands on different sides\n                    batch_reward += NIGHTSTAND_SIDE_BONUS_REWARD\n                elif proximal_nightstand_positions.shape[0] >= 2:\n                    # If not on different sides, just reward for the two closest ones' proximity\n                    # Sort distances and pick the two smallest valid ones\n                    sorted_distances = torch.sort(proximal_distances_xz)[0]\n                    batch_reward += NIGHTSTAND_PROXIMITY_REWARD_FACTOR * (1.0 - sorted_distances[0] / NIGHTSTAND_PROXIMITY_MAX_DIST)\n                    batch_reward += NIGHTSTAND_PROXIMITY_REWARD_FACTOR * (1.0 - sorted_distances[1] / NIGHTSTAND_PROXIMITY_MAX_DIST)\n                    # No side bonus here as they are not properly on opposite sides\n        \n        rewards[b] = batch_reward\n    \n    return rewards\n\n\ndef test_bedroom_setup_reward(**kwargs):\n    \"\"\"\n    Test the bedroom setup constraint reward function.\n    \"\"\"\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    \n    # Use the default idx_to_labels or provide one via kwargs\n    idx_to_labels = kwargs.get(\"idx_to_labels\", DEFAULT_BEDROOM_IDX_TO_LABELS)\n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    \n    # Ensure correct indices are present for testing, use fallbacks if not found\n    double_bed_idx = labels_to_idx.get(\"double_bed\", 8)\n    tv_stand_idx = labels_to_idx.get(\"tv_stand\", 19)\n    nightstand_idx = labels_to_idx.get(\"nightstand\", 12)\n    \n    num_classes = len(idx_to_labels)\n    empty_idx = labels_to_idx.get(\"empty\", num_classes - 1)\n    \n    print(f\"Using indices for testing: double_bed={double_bed_idx}, tv_stand={tv_stand_idx}, nightstand={nightstand_idx}, empty={empty_idx}\")\n\n    max_objects = 12 # Max objects allowed in the system\n    \n    # Define object parameters for test scenes\n    bed_pos_base = torch.tensor([1.0, 0.5, 0.0]) # Bed at (1, 0.5, 0)\n    bed_orient_forward_x = torch.tensor([1.0, 0.0]) # Faces +X (theta=0)\n    bed_orient_backward_x = torch.tensor([-1.0, 0.0]) # Faces -X (theta=pi)\n    bed_size = torch.tensor([1.0, 0.5, 0.8])\n\n    tv_pos_forward_x = torch.tensor([4.0, 0.5, 0.0]) # TV at (4, 0.5, 0) relative to bed_pos_base\n    tv_size = torch.tensor([0.5, 0.5, 0.3])\n\n    # Nightstand positions relative to bed_pos_base (1,0.5,0)\n    # Bed facing +X (forward_xz = (1,0)), side_xz = (0,1)\n    # Left nightstand: negative projection on side_xz (i.e., -Z direction)\n    # Right nightstand: positive projection on side_xz (i.e., +Z direction)\n    ns_pos_left_side = torch.tensor([0.5, 0.5, -0.8]) # Rel to bed: (-0.5, -0.8). proj on (0,1) = -0.8\n    ns_pos_right_side = torch.tensor([0.5, 0.5, 0.8]) # Rel to bed: (-0.5, 0.8). proj on (0,1) = 0.8\n    ns_pos_far = torch.tensor([5.0, 0.5, 0.0]) # Far away\n    ns_pos_same_side_1 = torch.tensor([0.5, 0.5, 0.8])\n    ns_pos_same_side_2 = torch.tensor([0.5, 0.5, 1.2]) # Further on the same side (+Z)\n    ns_size = torch.tensor([0.3, 0.6, 0.3])\n\n    # --- Test Case 1: Perfect scene - bed, TV, 2 nightstands (one each side), bed faces TV ---\n    print(\"\\n--- Test Case 1: Perfect scene (Max Reward) ---\")\n    \n    positions_1 = torch.tensor([\n        [bed_pos_base, tv_pos_forward_x, ns_pos_left_side, ns_pos_right_side] + \n        [[0.0, 0.0, 0.0]] * (max_objects - 4)\n    ], device=device)\n    sizes_1 = torch.tensor([\n        [bed_size, tv_size, ns_size, ns_size] + \n        [[0.01, 0.01, 0.01]] * (max_objects - 4)\n    ], device=device)\n    object_indices_1 = torch.tensor([\n        [double_bed_idx, tv_stand_idx, nightstand_idx, nightstand_idx] + \n        [empty_idx] * (max_objects - 4)\n    ], device=device, dtype=torch.long)\n    is_empty_1 = torch.tensor([\n        [False, False, False, False] + [True] * (max_objects - 4)\n    ], device=device)\n    orientations_1 = torch.tensor([\n        [bed_orient_forward_x, [1.0, 0.0], [0.0, 1.0], [0.0, 1.0]] + # Orient of NS don't matter much here\n        [[0.0, 0.0]] * (max_objects - 4)\n    ], device=device)\n    one_hot_1 = F.one_hot(object_indices_1, num_classes).float().to(device)\n    \n    parsed_scene_1 = {\n        \"positions\": positions_1, \"sizes\": sizes_1, \"object_indices\": object_indices_1,\n        \"is_empty\": is_empty_1, \"orientations\": orientations_1, \"one_hot\": one_hot_1, \"device\": device\n    }\n    \n    reward_1 = compute_bedroom_setup_reward(parsed_scene_1, idx_to_labels=idx_to_labels)\n    print(f\"Reward: {reward_1.item():.2f}\")\n    # Expected: 1 (bed) + 1 (tv_stand) + 0.5*2 (2 nightstands) = 3 (existence)\n    # Facing: ~2 (perfect alignment)\n    # Nightstands: Proximity (1-0.94/1.5)*1.0 = ~0.37 for each, sum ~0.74. Side bonus = 1.0. Total ~1.74\n    # Total expected: ~3 + 2 + 1.74 = 6.74\n    # Note: Using NIGHTSTAND_PROXIMITY_MAX_DIST=1.5, relative dist_xz for NS is sqrt(0.5^2 + 0.8^2) = 0.94m.\n    # (1 - 0.94/1.5) * 1.0 = 0.373 reward per nightstand.\n    assert reward_1.item() > 6.5, f\"Test 1 failed: Expected high reward (~6.74), got {reward_1.item():.2f}\"\n    \n    # --- Test Case 2: Missing TV stand ---\n    print(\"\\n--- Test Case 2: Missing TV stand ---\")\n    \n    positions_2 = torch.tensor([\n        [bed_pos_base, ns_pos_left_side, ns_pos_right_side] + \n        [[0.0, 0.0, 0.0]] * (max_objects - 3)\n    ], device=device)\n    sizes_2 = torch.tensor([\n        [bed_size, ns_size, ns_size] + \n        [[0.01, 0.01, 0.01]] * (max_objects - 3)\n    ], device=device)\n    object_indices_2 = torch.tensor([\n        [double_bed_idx, nightstand_idx, nightstand_idx] + \n        [empty_idx] * (max_objects - 3)\n    ], device=device, dtype=torch.long)\n    is_empty_2 = torch.tensor([\n        [False, False, False] + [True] * (max_objects - 3)\n    ], device=device)\n    orientations_2 = torch.tensor([\n        [bed_orient_forward_x, [0.0, 1.0], [0.0, 1.0]] + \n        [[0.0, 0.0]] * (max_objects - 3)\n    ], device=device)\n    one_hot_2 = F.one_hot(object_indices_2, num_classes).float().to(device)\n    \n    parsed_scene_2 = {\n        \"positions\": positions_2, \"sizes\": sizes_2, \"object_indices\": object_indices_2,\n        \"is_empty\": is_empty_2, \"orientations\": orientations_2, \"one_hot\": one_hot_2, \"device\": device\n    }\n    \n    reward_2 = compute_bedroom_setup_reward(parsed_scene_2, idx_to_labels=idx_to_labels)\n    print(f\"Reward: {reward_2.item():.2f}\")\n    # Expected: 1 (bed) + 0 (tv_stand) + 0.5*2 (2 nightstands) = 2 (existence)\n    # Facing: 0 (no tv_stand)\n    # Nightstands: ~1.74 (from above, proximity + side bonus)\n    # Total expected: ~2 + 0 + 1.74 = 3.74\n    assert reward_2.item() < reward_1.item() and reward_2.item() > 3.5, \\\n        f\"Test 2 failed: Expected reduced reward (~3.74), got {reward_2.item():.2f}\"\n\n    # --- Test Case 3: Bed facing away from TV ---\n    print(\"\\n--- Test Case 3: Bed facing away from TV ---\")\n    \n    # Bed at (1, 0.5, 0) facing -X (-1, 0). TV at (4, 0.5, 0)\n    # Direction from bed to TV is (+3,0). Bed orientation is (-1,0). Dot product = -1.\n    \n    orientations_3 = torch.tensor([\n        [bed_orient_backward_x, [1.0, 0.0], [0.0, 1.0], [0.0, 1.0]] + \n        [[0.0, 0.0]] * (max_objects - 4)\n    ], device=device)\n    \n    parsed_scene_3 = {\n        \"positions\": positions_1, \"sizes\": sizes_1, \"object_indices\": object_indices_1,\n        \"is_empty\": is_empty_1, \"orientations\": orientations_3, \"one_hot\": one_hot_1, \"device\": device\n    }\n    \n    reward_3 = compute_bedroom_setup_reward(parsed_scene_3, idx_to_labels=idx_to_labels)\n    print(f\"Reward: {reward_3.item():.2f}\")\n    # Expected: 3 (existence)\n    # Facing: ~0 (worst alignment, (dot + 1)/2 * scale = ((-1)+1)/2 * 2 = 0)\n    # Nightstands: ~1.74\n    # Total expected: ~3 + 0 + 1.74 = 4.74\n    assert reward_3.item() < reward_1.item() and reward_3.item() > 4.5, \\\n        f\"Test 3 failed: Expected reduced reward (~4.74), got {reward_3.item():.2f}\"\n\n    # --- Test Case 4: Only one nightstand, and it's far ---\n    print(\"\\n--- Test Case 4: Only one nightstand, far from bed ---\")\n    \n    positions_4 = torch.tensor([\n        [bed_pos_base, tv_pos_forward_x, ns_pos_far] + \n        [[0.0, 0.0, 0.0]] * (max_objects - 3)\n    ], device=device)\n    sizes_4 = torch.tensor([\n        [bed_size, tv_size, ns_size] + \n        [[0.01, 0.01, 0.01]] * (max_objects - 3)\n    ], device=device)\n    object_indices_4 = torch.tensor([\n        [double_bed_idx, tv_stand_idx, nightstand_idx] + \n        [empty_idx] * (max_objects - 3)\n    ], device=device, dtype=torch.long)\n    is_empty_4 = torch.tensor([\n        [False, False, False] + [True] * (max_objects - 3)\n    ], device=device)\n    orientations_4 = torch.tensor([\n        [bed_orient_forward_x, [1.0, 0.0], [0.0, 1.0]] + \n        [[0.0, 0.0]] * (max_objects - 3)\n    ], device=device)\n    one_hot_4 = F.one_hot(object_indices_4, num_classes).float().to(device)\n\n    parsed_scene_4 = {\n        \"positions\": positions_4, \"sizes\": sizes_4, \"object_indices\": object_indices_4,\n        \"is_empty\": is_empty_4, \"orientations\": orientations_4, \"one_hot\": one_hot_4, \"device\": device\n    }\n    \n    reward_4 = compute_bedroom_setup_reward(parsed_scene_4, idx_to_labels=idx_to_labels)\n    print(f\"Reward: {reward_4.item():.2f}\")\n    # Expected: 1 (bed) + 1 (tv_stand) + 0.5 (1 nightstand) = 2.5 (existence)\n    # Facing: ~2 (perfect alignment)\n    # Nightstands: 0 (only one, and too far from bed_pos_base [5.0,0.5,0] vs [1.0,0.5,0], dist_xz=4m > 1.5m)\n    # Total expected: ~2.5 + 2 + 0 = 4.5\n    assert reward_4.item() < reward_1.item() and reward_4.item() > 4.0, \\\n        f\"Test 4 failed: Expected low reward for bad nightstand count/placement (~4.5), got {reward_4.item():.2f}\"\n\n    # --- Test Case 5: Two nightstands, but both on the same side ---\n    print(\"\\n--- Test Case 5: Two nightstands, both on same side ---\")\n    \n    positions_5 = torch.tensor([\n        [bed_pos_base, tv_pos_forward_x, ns_pos_same_side_1, ns_pos_same_side_2] + \n        [[0.0, 0.0, 0.0]] * (max_objects - 4)\n    ], device=device)\n    sizes_5 = torch.tensor([\n        [bed_size, tv_size, ns_size, ns_size] + \n        [[0.01, 0.01, 0.01]] * (max_objects - 4)\n    ], device=device)\n    object_indices_5 = torch.tensor([\n        [double_bed_idx, tv_stand_idx, nightstand_idx, nightstand_idx] + \n        [empty_idx] * (max_objects - 4)\n    ], device=device, dtype=torch.long)\n    is_empty_5 = torch.tensor([\n        [False, False, False, False] + [True] * (max_objects - 4)\n    ], device=device)\n    orientations_5 = torch.tensor([\n        [bed_orient_forward_x, [1.0, 0.0], [0.0, 1.0], [0.0, 1.0]] + \n        [[0.0, 0.0]] * (max_objects - 4)\n    ], device=device)\n    one_hot_5 = F.one_hot(object_indices_5, num_classes).float().to(device)\n\n    parsed_scene_5 = {\n        \"positions\": positions_5, \"sizes\": sizes_5, \"object_indices\": object_indices_5,\n        \"is_empty\": is_empty_5, \"orientations\": orientations_5, \"one_hot\": one_hot_5, \"device\": device\n    }\n    \n    reward_5 = compute_bedroom_setup_reward(parsed_scene_5, idx_to_labels=idx_to_labels)\n    print(f\"Reward: {reward_5.item():.2f}\")\n    # Expected: 3 (existence)\n    # Facing: ~2 (perfect alignment)\n    # Nightstands: Proximity for 2 closest, but NO side bonus.\n    # ns_pos_same_side_1: rel to bed (-0.5, 0.8), dist_xz=0.94m. (1 - 0.94/1.5) = 0.373\n    # ns_pos_same_side_2: rel to bed (-0.5, 1.2), dist_xz=1.30m. (1 - 1.3/1.5) = 0.133\n    # Total nightstand reward = 0.373 + 0.133 = 0.506 (no side bonus)\n    # Total expected: ~3 + 2 + 0.506 = 5.506\n    assert reward_5.item() < reward_1.item() and reward_5.item() > 5.0, \\\n        f\"Test 5 failed: Expected reduced reward (no side bonus, ~5.51), got {reward_5.item():.2f}\"\n\n    print(\"\\n\u2713 All tests passed!\")\n\n\nif __name__ == \"__main__\":\n    test_bedroom_setup_reward()"
}